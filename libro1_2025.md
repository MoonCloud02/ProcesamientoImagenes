# INTRODUCCIÓN AL PROCESAMIENTO ESPACIAL DE IMÁGENES

**Versión en Desarrollo**

**Autores:**
- JIMY ALEXANDER CORTÉS OSORIO
- FRANCISCO ALEJANDRO MEDINA AGUIRRE

**Institución:**
UNIVERSIDAD TECNOLÓGICA DE PEREIRA
FACULTAD DE CIENCIAS BÁSICAS
PEREIRA
2025

---

## Dedicatoria

A nuestros estudiantes quienes han hecho de esta guía un documento de referencia.

---

## Agradecimientos

A los programas de Ingeniería Mecatrónica e Ingeniería Física de la Universidad Tecnológica de Pereira, por sus aportes académicos a través de sus estudiantes:
- Ingeniero Alejandro Arroyabe
- Ingeniero Daniel Felipe Socha
- Ingeniero Juan Pablo Peláez
- Ingeniera María Camila Quintero

Y los profesores:
- Magister Marlen Julieth Suárez

Al amigo eterno Magister Andrew Murray Knott (QEPD) por sus aportes, disposición y ayuda desinteresada a la realización del presente documento.

---

## Índice General

### Capítulos Principales

1. [Antecedentes](#antecedentes)
2. [La Cámara](#la-cámara)
3. [La Imagen](#la-imagen)
4. [Ajuste y Ecualización](#ajuste-y-ecualización)
5. [Modelos Básicos del Color](#modelos-básicos-del-color)
6. [Conversión a Escala de Grises](#conversión-a-escala-de-grises)
7. [Binarización](#binarización)
8. [El Ruido](#el-ruido)
9. [Filtros Espaciales](#filtros-espaciales)
10. [Transformaciones Espaciales](#transformaciones-espaciales)
11. [Operaciones Morfológicas Binarias](#operaciones-morfológicas-binarias)
12. [Etiquetado](#etiquetado)
13. [Funciones de Python](#funciones-de-python)

---

## INTRODUCCIÓN

El procesamiento de imágenes es una disciplina fundamental en la visión por computador y tiene aplicaciones en medicina, robótica, astronomía y muchas otras áreas. Este libro desarrolla los conceptos fundamentales desde los principios ópticos hasta técnicas avanzadas de segmentación.

---

# 1. Antecedentes

## 1.1 Antecedentes del Procesamiento de Imágenes

### 1.1.1 Algunos Momentos Históricos de la Fotografía

La fotografía ha evolucionado significativamente desde su invención. Entre los hitos más importantes se encuentran:

- El desarrollo de la tecnología CCD (Charge-Coupled Device) por Willard S. Boyle y George E. Smith
- La primera fotografía a color de la Historia
- La evolución del retoque de imágenes
- La transmisión de imágenes

### 1.1.2 La Primera Fotografía a Color de la Historia

James Clerk Maxwell realizó el primer experimento de fotografía a color en 1861, utilizando tres filtros de color separados.

### 1.1.3 Retoque de Imágenes

A lo largo de la historia, se ha editado imágenes tanto para propósitos artísticos como políticos, incluyendo manipulaciones realizadas por:
- La Unión Soviética
- Benito Mussolini
- Adolf Hitler

### 1.1.4 Sobre la Transmisión de Imágenes

La transmisión de imágenes desde la Luna durante la misión Apolo fue un hito importante en el procesamiento digital de imágenes, utilizando técnicas de procesamiento en semitonos.

## 1.2 Preguntas

### Preguntas de Comprensión:
- ¿Cuál fue la primera fotografía digital de la historia?
- ¿Quiénes fueron los inventores de la tecnología CCD?

### Preguntas de Aplicación y Evaluación:
- Investigue sobre la evolución histórica del procesamiento de imágenes
- Analice las implicaciones éticas del retoque de imágenes

---

# 2. La Cámara

## 2.1 La Luz

### 2.1.1 Naturaleza de la Luz

La luz es una radiación electromagnética visible por el ojo humano, ubicada en el espectro electromagnético entre los 380 y 700 nanómetros aproximadamente.

### 2.1.2 El Ojo Humano

El ojo humano contiene tres tipos de fotorreceptores (conos) sensibles a diferentes longitudes de onda:
- Rojo (~700 nm)
- Verde (~550 nm)
- Azul (~450 nm)

## 2.2 La Cámara

### 2.2.1 Formación del Imagen

La formación de imágenes sigue principios ópticos fundamentales que han sido estudiados durante siglos.

### 2.2.2 Formación de Imagen en la Cámara Estenopeica

La cámara estenopeica es el modelo más simple de formación de imágenes, donde la luz pasa a través de un pequeño agujero.

### 2.2.3 Formación de Imágenes con Lentes Delgadas

Las lentes delgadas convergentes crean imágenes enfocadas en el plano focal de la cámara.

## 2.3 Cámara Digital

### 2.3.1 Componentes Básicos

Una cámara digital moderna contiene:
- Objetivo (lente)
- Sensor de imagen (CCD o CMOS)
- Procesador
- Tarjeta de memoria

## 2.4 Principio Básico del Color

### 2.4.1 Cámara con Tres Arreglos

Los sistemas profesionales utilizan tres sensores separados, uno para cada canal de color (RGB).

### 2.4.2 Cámara con un Solo Arreglo

Las cámaras de consumo utilizan un filtro Bayer que interpola los valores de color.

### 2.4.3 Ejemplo en Python: Separación de Capas de Color

El código permite separar una imagen en sus componentes R, G, B individuales.

## 2.5 Funciones

Se describen funciones de Python para trabajo con cámaras y procesamiento de color.

## 2.6 Preguntas

### Preguntas sobre Hechos del Texto:
- ¿Cuál es el rango visible de la luz para el ojo humano?
- ¿Qué es un filtro Bayer?

### Preguntas de Análisis y Comprensión sobre el Texto:
- Compare las ventajas y desventajas de sistemas 3CCD vs 1CCD
- Explique cómo funciona la interpolación de color en filtros Bayer

---

# 3. La Imagen

## 3.1 La Imagen

### 3.1.1 Definición y Tipos

Una imagen es una representación visual de una escena. Las imágenes pueden ser:
- Artísticas
- Fotográficas
- Científicas

## 3.2 La Imagen Digital

Una imagen digital es una representación discreta de una imagen, compuesta por píxeles (elementos de imagen).

## 3.3 La Imagen a Color

### 3.3.1 Ejemplo en Python: Creación de Píxeles de Colores

El código permite crear píxeles individuales con valores RGB específicos.

## 3.4 La Resolución Espacial

La resolución espacial determina el nivel de detalle que puede representar una imagen digital. Se mide en píxeles de ancho por píxeles de alto.

## 3.5 La Profundidad del Color

La profundidad de color indica cuántos valores diferentes puede tomar cada píxel:
- 1 bit: 2 colores (blanco y negro)
- 8 bits: 256 valores (escala de grises)
- 24 bits: 16.7 millones de colores (RGB)

## 3.6 Algunos Formatos Gráficos

### 3.6.1 JPEG

Formato comprimido con pérdida, ideal para fotografías. Reduce el tamaño de archivo significativamente.

### 3.6.2 PNG

Formato sin pérdida con soporte para transparencia. Ideal para gráficos.

### 3.6.3 GIF

Formato con paleta de colores limitada, soporta animaciones.

### 3.6.4 TIFF

Formato versátil que puede ser sin pérdida o con compresión.

### 3.6.5 BMP

Formato sin compresión, produce archivos grandes.

### 3.6.6 RAW

Formato sin procesar, captura los datos directos del sensor.

## 3.7 Funciones

Se describen funciones de Python para manipulación de imágenes digitales.

## 3.8 Preguntas

### Preguntas de Comprensión
- ¿Cuál es la diferencia entre resolución espacial y profundidad de color?
- ¿Por qué PNG es preferible a JPEG para gráficos?

### Preguntas de Aplicación y Evaluación
- Analice los trade-offs entre tamaño de archivo y calidad de imagen
- Determine cuál es el formato más adecuado para diferentes aplicaciones

---

# 4. Ajuste y Ecualización

## 4.1 El Histograma de una Imagen

### 4.1.1 Ejemplo en Python: Extracción de Capas e Histogramas

El histograma es la distribución de frecuencias de los valores de intensidad en una imagen.

### 4.1.2 El Brillo

El brillo es el promedio general de intensidad en la imagen. Una imagen con bajo brillo tiene un histograma concentrado hacia los valores oscuros.

### 4.1.3 El Contraste

El contraste es la diferencia entre los valores más claros y más oscuros. Alto contraste significa que la imagen utiliza todo el rango de valores disponibles.

## 4.2 Normalización del Histograma

### 4.2.1 Ajuste por Potencia del Histograma

La corrección gamma permite ajustar el brillo de manera no lineal:

$$I' = I^{\gamma}$$

donde $\gamma$ es el factor de corrección.

### 4.2.2 Ejemplo en Clase: Ajuste del Histograma por Potencia

Se demostró cómo aplicar corrección gamma a una imagen.

### 4.2.3 Ajuste Exponencial del Histograma

Se utiliza una función exponencial para el ajuste:

$$I' = e^{I} - 1$$

### 4.2.4 Ajuste Logarítmico del Histograma

Se utiliza una función logarítmica:

$$I' = \ln(1 + I)$$

### 4.2.5 Determinación de los Valores Em y EM

Se definen los límites de entrada basados en el histograma acumulado.

### 4.2.6 Ejemplo en Python: Ajuste de una Imagen

Se implementa el ajuste de histograma en Python.

## 4.3 Ecualización del Histograma

### 4.3.1 Ejemplo en Clase: Ecualización

La ecualización del histograma distribuye uniformemente los valores de intensidad.

### 4.3.2 Ejemplo en Clase: Ajuste por Ecualización

Se demuestra el proceso paso a paso.

### 4.3.3 Ejemplo en Python: Ecualización de una Imagen

Se implementa la ecualización en Python.

## 4.4 Histograma por Especificación

### 4.4.1 Algoritmo Histograma por Especificación usando el Mayor Vecino Más Cercano

Se especifica un histograma deseado y se transforma la imagen para lograrlo.

### 4.4.2 Algoritmo Histograma por Especificación usando Interpolación Lineal

Se utiliza interpolación para suavizar la transformación.

### 4.4.3 Ejemplo en Clase: Ajuste por Especificación

Se demuestra paso a paso.

### 4.4.4 Ejemplo en Python: Ecualización por Especificación

Se implementa en Python.

## 4.5 Funciones

Se describen funciones para manipulación de histogramas.

## 4.6 Preguntas

### Preguntas sobre Hechos Indicados en el Texto:
- ¿Qué es la corrección gamma?
- ¿Cómo se distribuyen los valores en una imagen ecualizada?

### Preguntas de Análisis y Comprensión con Base en el Texto:
- Explique cuándo es apropiado usar cada tipo de ajuste
- Compare la ecualización lineal con la especificación de histograma

### Ejercicios Numéricos
- Calcule la transformación de histograma para casos específicos

---

# 5. Modelos Básicos del Color

## 5.1 El Concepto del Color

El color es la percepción visual de diferentes longitudes de onda de luz. El ojo humano percibe color a través de tres tipos de conos sensibles a rangos diferentes de longitud de onda.

## 5.2 Modelos del Color

### 5.2.1 Modelo de Color CIE XYZ

El modelo CIE XYZ es un estándar internacional que define el color de manera independiente del dispositivo.

### 5.2.2 Modelo de Color RGB

El modelo RGB (Rojo, Verde, Azul) es el más utilizado en dispositivos como monitores y cámaras.

### 5.2.3 Modelo del Color CMYK

El modelo CMYK (Cyan, Magenta, Yellow, Black) se utiliza en impresión.

### 5.2.4 Modelo de Color HSV

El modelo HSV (Hue, Saturation, Value) es más intuitivo para humanos:
- **Hue (Matiz)**: El color en sí (0-360°)
- **Saturation (Saturación)**: La pureza del color (0-100%)
- **Value (Valor)**: El brillo (0-100%)

### 5.2.5 a 5.2.14 Conversiones Entre Modelos

Se presentan las fórmulas matemáticas para convertir entre diferentes espacios de color:
- RGB a CMYK
- CMYK a RGB
- RGB a HSV
- HSV a RGB
- RGB a XYZ
- XYZ a RGB
- XYZ a Lab
- Lab a XYZ
- Lab a RGB
- RGB a Lab

## 5.3 Ejemplo Segmentación

### 5.3.1 Ejemplo en Python: Segmentación de la Bandera Usando el Modelo RGB

Se demuestra cómo segmentar colores específicos usando rangos en el modelo RGB.

### 5.3.2 Ejemplo en Python: Segmentación de la Bandera Usando el Modelo HSV

La segmentación es más intuitiva en el espacio HSV, donde se define un rango de matiz.

### 5.3.3 Ejemplo en Python: Segmentación de la Bandera Usando el Modelo CIELab

El modelo Lab es perceptualmente uniforme, lo que lo hace útil para segmentación.

## 5.4 Funciones

Se presentan funciones Python para conversiones de color.

## 5.5 Preguntas

### Preguntas Directas sobre el Texto
- ¿Cuál es la diferencia entre RGB y CMYK?
- ¿Cuándo es más útil usar HSV en lugar de RGB?

### Preguntas de Análisis y Comprensión con Base en el Texto
- Explique por qué Lab es perceptualmente uniforme
- Analice las ventajas y desventajas de cada modelo de color

### Preguntas de Cálculos
- Convierta valores RGB a HSV
- Convierta valores CMYK a RGB

---

# 6. Conversión a Escala de Grises

## 6.1 El Problema

La conversión de una imagen RGB a escala de grises requiere combinar los tres canales de color en un solo valor.

## 6.2 Técnica del Promedio

La forma más simple es promediar los tres canales:

$$Gray = \frac{R + G + B}{3}$$

## 6.3 Técnica del Midgray

Una variante utiliza el valor intermedio:

$$Gray = \frac{\max(R,G,B) + \min(R,G,B)}{2}$$

## 6.4 Técnica de la Luminancia

La técnica más precisa utiliza los pesos perceptivos del ojo humano:

$$Gray = 0.299R + 0.587G + 0.114B$$

Esta es la recomendación NTSC 601, la más utilizada.

## 6.5 Conversión de Escala de Grises a Color

Una imagen en escala de grises puede convertirse a color replicando el valor en los tres canales RGB.

### 6.5.1 Ejemplo en Python: Segmentación por Color y Grises

Se demuestra cómo segmentar una imagen utilizando tanto información de color como de escala de grises.

## 6.6 Funciones

Se presentan funciones Python para conversión de color.

## 6.7 Preguntas

### Preguntas de Hechos Indicados en el Texto
- ¿Cuáles son las ponderaciones en la fórmula NTSC 601?
- ¿Por qué no se utiliza un promedio simple?

### Preguntas de Comprensión con Base en el Texto
- Explique la diferencia entre las tres técnicas presentadas
- ¿Cuál es la ventaja de la técnica de luminancia?

### Ejercicios Numéricos con Base en el Texto
- Convierta píxeles RGB específicos a escala de grises

---

# 7. Binarización

## 7.1 Técnicas Globales

### 7.1.1 Método Global Iterativo

El método iterativo de Ridler ajusta iterativamente un umbral inicial.

### 7.1.2 Método Global de la Entropía

Se maximiza la entropía entre el objeto y el fondo.

### 7.1.3 Método Global de Otsu

El método de Otsu maximiza la varianza entre clases.

### 7.1.4 Comparación de los Métodos Globales Presentados

Se comparan los tres métodos en términos de eficacia y velocidad.

## 7.2 Técnicas Adaptivas

### 7.2.1 Método Adaptivo de Niblack

El método de Niblack calcula un umbral local basado en la media y desviación estándar local.

### 7.2.2 Método Adaptivo de Sauvola

Una mejora del método de Niblack que considera la varianza local.

### 7.2.3 Método Adaptivo de Bradley

El método de Bradley utiliza la integral de imagen para cálculos eficientes.

## 7.3 Funciones

Se presentan funciones Python para binarización.

## 7.4 Preguntas

### Preguntas sobre Hechos Indicados en el Texto
- ¿Cuál es la ventaja del método de Otsu?
- ¿Cuándo se utiliza binarización adaptiva en lugar de global?

### Preguntas de Análisis y Comprensión con Base en el Texto
- Explique cómo funcionan los métodos adaptativos
- Analice cuándo cada método es más apropiado

### Ejercicios Numéricos
- Aplique el método de Otsu a histogramas específicos

---

# 8. El Ruido

## 8.1 El Ruido

El ruido es variación aleatoria no deseada en la intensidad de los píxeles de una imagen.

## 8.2 Fuentes de Ruido

### 8.2.1 Ruido Impulsivo (Sal y Pimienta)

Píxeles alterados a valores extremos (0 o 255).

### 8.2.2 Ruido Gaussiano

Ruido que sigue una distribución gaussiana (normal).

### 8.2.3 Ruido Speckle

Ruido multiplicativo que depende de la intensidad local.

## 8.3 Evaluación Referencial del Filtrado de Imágenes

### 8.3.1 Error Cuadrático Medio (MSE)

$$MSE = \frac{1}{M \times N} \sum_{i=0}^{M-1} \sum_{j=0}^{N-1} [I(i,j) - \hat{I}(i,j)]^2$$

### 8.3.2 Ejemplo Cálculo de MSE

Se demuestra cómo calcular el MSE entre dos imágenes.

### 8.3.3 Relación Señal-Ruido de Pico (PSNR)

$$PSNR = 10 \log_{10}\left(\frac{255^2}{MSE}\right)$$

### 8.3.4 Ejemplo Cálculo de PSNR

Se calcula el PSNR para comparar imágenes.

### 8.3.5 Índice de Similitud Estructural (SSIM)

Una métrica más perceptual que MSE y PSNR.

### 8.3.6 Ejemplo Cálculo de SSMI

Se demuestra cómo calcular SSIM.

## 8.4 Funciones

Se presentan funciones Python para trabajo con ruido.

## 8.5 Preguntas

### Preguntas sobre Hechos del Texto
- ¿Cuál es la diferencia entre ruido gaussiano y speckle?
- ¿Cuándo es PSNR preferible a MSE?

### Preguntas de Análisis y Comprensión sobre el Texto
- Explique por qué SSIM es superior a PSNR
- Analice los tipos de ruido y sus fuentes

### Problemas Numéricos sobre Ruido en Imágenes
- Calcule MSE y PSNR para casos específicos

---

# 9. Filtros Espaciales

## 9.1 Filtrado Espacial de Imágenes

El filtrado espacial modifica los píxeles de una imagen basándose en los valores de los píxeles vecinos.

## 9.2 Operaciones Espaciales

### 9.2.1 Correlación en Dos Dimensiones

La correlación desplaza un kernel (máscara) sobre la imagen:

$$R(i,j) = \sum_{u,v} K(u,v) \cdot I(i+u, j+v)$$

### 9.2.2 Convolución en Dos Dimensiones

La convolución es similar a la correlación pero con el kernel invertido:

$$C(i,j) = \sum_{u,v} K(u,v) \cdot I(i-u, j-v)$$

### 9.2.3 Ejemplo: Evaluación de la Correlación y la Convolución

Se demuestra paso a paso cómo realizar estas operaciones.

## 9.3 Equivalencia entre Correlación y Convolución

Cuando el kernel es simétrico, ambas operaciones son equivalentes.

## 9.4 Solución

Se describe cómo manejar los bordes de la imagen durante el filtrado.

## 9.5 Tipos de Relleno

### 9.5.1 Relleno de Constante (Constant Padding)

Se rellena con un valor constante especificado.

### 9.5.2 Relleno Cero (Zero Padding)

Se rellena con ceros.

### 9.5.3 Relleno Replicado (Replicate Padding)

Se replica el valor del píxel en el borde.

### 9.5.4 Relleno Simétrico (Symmetric Padding)

Se refleja la imagen simétricamente.

### 9.5.5 Relleno Cíclico (Circular Padding)

Se envuelve la imagen alrededor de los bordes.

## 9.6 Filtros de Suavizado (Pasa-Bajo)

### 9.6.1 Filtro Aritmético

El filtro de promedio aritmético suaviza la imagen:

$$I'(i,j) = \frac{1}{N} \sum I(u,v)$$

donde N es el número de píxeles en la ventana.

### 9.6.2 Filtros de Orden

Filtros basados en el ordenamiento de valores.

### 9.6.3 Filtro Mediana

Reemplaza cada píxel con la mediana de sus vecinos. Excelente para ruido de sal y pimienta.

### 9.6.4 Filtro Moda

Reemplaza con el valor más frecuente.

### 9.6.5 Filtro Desviación Estándar

Útil para detectar cambios en la textura.

### 9.6.6 Filtro Entropía

Identifica regiones con mayor complejidad informativa.

### 9.6.7 Ejemplo en Python: Filtros Espaciales

Se implementan varios filtros en Python.

### 9.6.8 Filtro Gaussiano

$$K(u,v) = \frac{1}{2\pi\sigma^2} e^{-\frac{u^2+v^2}{2\sigma^2}}$$

El filtro gaussiano produce un desenfoque suave y natural.

### 9.6.9 Ejemplo en Python: Filtros Pasa Bajo

Se demuestra cómo aplicar filtros pasa-bajo.

## 9.7 Filtros de Detector de Bordes (Pasa-Alto)

### 9.7.1 El Gradiente

El gradiente apunta en la dirección de máximo cambio:

$$\nabla I = \begin{bmatrix} \frac{\partial I}{\partial x} \\ \frac{\partial I}{\partial y} \end{bmatrix}$$

$$|\nabla I| = \sqrt{\left(\frac{\partial I}{\partial x}\right)^2 + \left(\frac{\partial I}{\partial y}\right)^2}$$

### 9.7.2 El Laplaciano

El laplaciano es la suma de derivadas segunda:

$$\nabla^2 I = \frac{\partial^2 I}{\partial x^2} + \frac{\partial^2 I}{\partial y^2}$$

### 9.7.3 Filtro Laplaciano del Gaussiano

Combina el suavizado gaussiano con la detección de bordes.

### 9.7.4 Filtro Sharpen

Acentúa los bordes amplificando el laplaciano.

### 9.7.5 Filtro Sobel

Detecta bordes en direcciones específicas:

$$G_x = \begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{bmatrix}$$

$$G_y = \begin{bmatrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1 \end{bmatrix}$$

### 9.7.6 Filtro Prewitt

Similar a Sobel pero con pesos diferentes.

### 9.7.7 Ejemplo en Python: Filtros Pasa Alto

Se implementan detectores de bordes.

## 9.8 Preguntas

### Preguntas sobre Hechos Indicados en el Texto
- ¿Cuál es la diferencia entre correlación y convolución?
- ¿Cuándo se utiliza un filtro mediana en lugar de promedio?

### Preguntas de Análisis y Comprensión con Base en el Texto
- Explique por qué el filtro gaussiano es superior al promedio simple
- Analice las ventajas de diferentes tipos de relleno

### Ejercicios Numéricos
- Aplique filtros manualmente a pequeñas matrices

---

# 10. Transformaciones Espaciales

## 10.1 Método de Transformación Directo

Se calcula directamente dónde va cada píxel en la imagen de salida.

## 10.2 Método de Transformación Inverso

Se calcula para cada píxel de salida dónde vino de la imagen de entrada. Este es generalmente preferible.

## 10.3 Transformaciones en Sistema Cartesiano y Matricial

### 10.3.1 Sistema de Coordenadas Cartesiano

Usa coordenadas (x, y) donde x es horizontal e y es vertical.

### 10.3.2 Sistema Matricial

Usa índices (i, j) donde i es fila (vertical) y j es columna (horizontal).

### 10.3.3 Interpretación de Coordenadas

Se debe convertir cuidadosamente entre los dos sistemas.

### 10.3.4 Aplicación de Transformaciones a Imágenes

Se utilizan coordenadas homogéneas para facilitar las operaciones matriciales.

## 10.4 Transformaciones Geométricas Afines

### 10.4.1 Traslación

Desplaza la imagen por un vector (tx, ty):

$$\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = \begin{bmatrix} 1 & 0 & tx \\ 0 & 1 & ty \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$$

### 10.4.2 Algoritmo Inverso de Traslación

Se utiliza la transformación inversa en el método inverso.

### 10.4.3 Escalamiento

Cambia el tamaño de la imagen:

$$\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = \begin{bmatrix} S_x & 0 & 0 \\ 0 & S_y & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$$

### 10.4.4 Algoritmo Inverso de Escalamiento

Se utiliza el inverso del factor de escala.

### 10.4.5 Rotación

Rota la imagen alrededor de su centro:

$$\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = \begin{bmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$$

### 10.4.6 Algoritmo Inverso de Rotación

Se utiliza $-\theta$ en la matriz de rotación.

### 10.4.7 Ejemplo en Python: Transformaciones Afines Básicas

Se implementan transformaciones básicas.

### 10.4.8 Cizallamiento

Deforma la imagen según un ángulo especificado.

### 10.4.9 Algoritmo Inverso de Cizallamiento

Se utiliza la transformación inversa.

## 10.5 Transformación Proyectiva

Una transformación proyectiva es más general que una afín, permitiendo cambios de perspectiva.

### 10.5.1 Ejemplo en Python: Transformaciones Proyectivas

Se implementan transformaciones proyectivas.

## 10.6 Interpolaciones

### 10.6.1 Vecino Más Cercano

Asigna el valor del píxel más cercano. Rápido pero produce artefactos.

### 10.6.2 Interpolación Bilineal

Interpola linealmente entre cuatro píxeles vecinos. Mejor calidad que vecino más cercano.

## 10.7 Funciones

Se presentan funciones Python para transformaciones geométricas.

## 10.8 Preguntas

### Preguntas sobre Hechos Indicados en el Texto
- ¿Cuál es la ventaja del método inverso sobre el directo?
- ¿Cuándo se usa interpolación bilineal en lugar de vecino más cercano?

### Preguntas de Análisis y Comprensión
- Explique cómo funcionan las coordenadas homogéneas
- Analice las diferencias entre transformaciones afines y proyectivas

### Ejercicios Numéricos
- Calcule transformaciones manualmente

---

# 11. Operaciones Morfológicas Binarias

## 11.1 Conceptos Básicos de Teoría de Conjuntos y Lógica Binaria

### 11.1.1 Unión y el OR Lógico

La unión de dos conjuntos es el conjunto que contiene todos los elementos de ambos.

### 11.1.2 Intersección y AND Lógico

La intersección contiene solo los elementos comunes.

### 11.1.3 Complemento y el NOT Lógico

El complemento invierte todos los valores binarios.

## 11.2 El Elemento Estructurante

El elemento estructurante es una pequeña matriz que define la forma y tamaño del "pincel" morfológico.

### 11.2.1 Elemento Estructurante Cuadrado

Una matriz cuadrada de 1s.

### 11.2.2 Elemento Estructurante Rectángulo

Una matriz rectangular de 1s.

### 11.2.3 Elemento Estructurante Disco

Una aproximación circular.

### 11.2.4 Elemento Estructurante Cruz

Una forma de cruz.

### 11.2.5 Elemento Estructurante Línea

Una línea recta.

## 11.3 La Erosión

La erosión es una operación morfológica que reduce el tamaño de los objetos.

## 11.4 Algoritmo de Erosión

1. Definir la imagen de entrada y el elemento estructurante.
2. Para cada píxel: si el elemento estructurante coincide completamente con píxeles blancos, mantener blanco.
3. Devolver la imagen erosionada.

## 11.5 La Dilatación

La dilatación expande los objetos.

### 11.5.1 Algoritmo de Dilatación

1. Definir la imagen de entrada y el elemento estructurante.
2. Para cada píxel: si el elemento estructurante toca algún píxel blanco, hacerlo blanco.
3. Devolver la imagen dilatada.

## 11.6 Dualidad entre Erosión y Dilatación

La erosión y dilatación son duales bajo complementación:

$$I \ominus S = (I^c \oplus S^r)^c$$

$$I \oplus S = (I^c \ominus S^r)^c$$

donde $I^c$ es el complemento de I, $S^r$ es la reflexión de S, $\ominus$ es erosión, y $\oplus$ es dilatación.

## 11.7 La Apertura Morfológica

La apertura es erosión seguida de dilatación. Elimina detalles pequeños mientras preserva la forma general.

### 11.7.1 Algoritmo Apertura

1. Definir la imagen de entrada y el elemento estructurante.
2. Realizar erosión.
3. Realizar dilatación sobre el resultado.
4. Devolver la imagen abierta.

## 11.8 El Cerramiento Morfológico

El cerramiento es dilatación seguida de erosión. Cierra pequeños agujeros.

### 11.8.1 Algoritmo de Cerramiento

1. Definir la imagen de entrada y el elemento estructurante.
2. Realizar dilatación.
3. Realizar erosión sobre el resultado.
4. Devolver la imagen cerrada.

### 11.8.2 Ejemplo en Python: Segmentación mediante Morfología

Se demuestra cómo usar operaciones morfológicas para segmentar objetos en una imagen.

## 11.9 Funciones

Se describen funciones MATLAB equivalentes para operaciones morfológicas.

## 11.10 Preguntas

### Preguntas sobre Hechos Indicados en el Texto
- ¿Cuál es la función del elemento estructurante?
- ¿Cuál es la diferencia entre erosión y dilatación?

### Preguntas de Análisis y Comprensión con Base en el Texto
- Explique la dualidad entre erosión y dilatación
- Analice cuándo usar apertura versus cerramiento

### Ejercicios Numéricos
- Realice erosión y dilatación manualmente en matrices pequeñas
- Realice apertura y cerramiento manualmente

---

# 12. Etiquetado

## 12.1 Análisis de Componente Conexos

El análisis de componentes conexos identifica regiones separadas en una imagen binaria.

## 12.2 Conectores Bidimensionales

### 12.2.1 Conector 4

Los píxeles están conectados si sus bordes se tocan (conectividad en cruz).

### 12.2.2 Conector 8

Los píxeles están conectados si sus bordes o esquinas se tocan (conectividad completa).

### 12.2.3 Proceso de Etiquetado

El etiquetado se realiza típicamente con un algoritmo de dos pasadas:

**Primera Pasada:**
1. Recorrer la imagen de izquierda a derecha, de arriba a abajo
2. Para cada píxel del objeto, revisar sus vecinos ya procesados
3. Si ninguno tiene etiqueta, asignar una nueva
4. Si tienen etiquetas, asignar la mínima y registrar equivalencias

**Segunda Pasada:**
1. Recorrer nuevamente
2. Reemplazar cada etiqueta con su equivalente mínima

### 12.2.4 Ejemplo en Clase: Etiquetado de Regiones

Se demuestra paso a paso el proceso de etiquetado.

### 12.2.5 Ejemplo Python: Etiquetado de Regiones

Se implementa el etiquetado en Python.

## 12.3 Funciones

Se describen funciones para análisis de componentes conectados.

## 12.4 Preguntas

### Preguntas sobre Hechos Indicados en el Texto
- ¿Qué es un componente conexo?
- ¿Por qué se utiliza un algoritmo de dos pasadas?

### Preguntas de Análisis y Comprensión con Base en el Texto
- Explique la diferencia entre conectividad 4 y 8
- Analice cuándo cada tipo de conectividad es más apropiado

### Ejercicio Numérico
- Aplique el algoritmo de etiquetado a una matriz binaria pequeña

---

# 13. Funciones de Python

Se presenta una biblioteca completa de funciones Python para procesamiento de imágenes, incluyendo:

- Histogramas y estadísticas
- Ajuste y ecualización
- Conversiones de espacios de color
- Binarización (global y adaptiva)
- Filtrado espacial
- Transformaciones geométricas
- Operaciones morfológicas
- Etiquetado

Todas las funciones se presentan con documentación completa, parámetros y ejemplos de uso.

---

## Bibliografía

Se incluye una bibliografía completa con más de 50 referencias que cubren:

- Teoría de procesamiento digital de imágenes
- Visión por computador
- Procesamiento morfológico
- Calidad de imagen
- Historia de la fotografía
- Espacios de color y colorimetría

Entre los autores referenciados se encuentran:
- Gonzalez y Woods
- Burger y Burge
- Szeliski
- Hartley y Zisserman
- Y muchos otros expertos en el campo

---

## Resumen

Este libro proporciona una introducción completa y práctica al procesamiento espacial de imágenes, combinando:

- **Teoría fundamental**: Conceptos básicos de óptica, cámaras digitales y percepción del color
- **Técnicas de preprocesamiento**: Histogramas, ecualización y ajuste de contraste
- **Segmentación**: Binarización global y adaptiva
- **Filtrado**: Pasa-bajo para suavizado y pasa-alto para detección de bordes
- **Transformaciones geométricas**: Rotación, escalamiento y transformaciones proyectivas
- **Morfología matemática**: Erosión, dilatación, apertura y cerramiento
- **Análisis de regiones**: Etiquetado de componentes conectados

Cada capítulo incluye:
- Explicación teórica clara
- Ejemplos en Python
- Problemas resueltos paso a paso
- Preguntas de autoevaluación
- Ejercicios numéricos

**Versión en Desarrollo - 2025**
Universidad Tecnológica de Pereira